# 强缓存与协商缓存

# 基本原理

1. 浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
2. 如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和Etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
3. 如果前面两者都没有命中，直接从服务器加载资源

## 强缓存

通过expires或者cache-control实现，前端发送请求后，服务器响应可能会带上expires字段或是cache-control字段。

其中expires字段是http1.0提出的一个表示资源过期时间的header，描述的是一个绝对时间，由服务器返回。expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效

    Expires: Wed, 11 May 2018 07:20:00 GMT

Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间

cache-control的字段有：
* max-age  表示资源失效时间
* no-cache  在与服务器验证资源新鲜度之前不能把缓存提供给客户端使用
* no-store  不缓存数据到本地
* public  可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
* private  只能被终端浏览器缓存（而且是私有缓存），不允许中继缓存服务器进行缓存


## 协商缓存

协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的，在进行协商缓存时应该优先查看是否有Etag，若有Etag则使用Etag与服务器进行资源新鲜度的检查，也就是说其实这时候只要带上If-None-Match这个字段。如果检查发现之前没有返回Etag，那么就带上If-Modified-Since这个字段。也就是说ETag的优先级比Last-Modified更高

具体为什么要用ETag，主要出于下面几种情况考虑：

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
3. 某些服务器不能精确的得到文件的最后修改时间


## 但是下面的场景需要注意：

1. 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；
2. 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；