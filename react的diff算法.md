# react的diff算法

> diff算法采用的依旧是深度优先遍历的算法，只是对此进行了优化，使其时间复杂度大大降低
## diff 策略
* Web UI中节点跨级操作特别少，可以忽略不计
* 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。（哪怕一样的而我也认为不一样 -> 大概率优化）
* 对于同一层级的一组子节点，他们可以通过唯一的key来区分，以方便后续的列表对比算法

> 基于如上，React分别对tree diff、Component diff 、element diff 进行了算法优化。

### tree diff
> 基于策略一，React的diff非常简单明了：只会对同一层次的节点进行比较。这种非传统的按深度遍历搜索，这种通过大胆假设得到的改进方案，不仅符合实际场景的需要，而且大幅降低了算法实现复杂度，从O(n^3)提升至O(n)。

> 基于此，React官方并不推荐进行DOM节点的跨层级操作 ，倘若真的出现了，那就是非常消耗性能的remove和create的操作了。

### Component diff
> 由于React是基于组件开发的，所以组件的dom diff其实也非常简单，如果组件是同一类型，则进行tree diff比较。如果不是，则直接放入到patches中。即使是子组件结构类型都相同，只要父组件类型不同，都会被重新渲染。这也说明了为什么我们推荐使用shouldComponentUpdate来提高React性能。
> 在开发组件时，保持稳定的 DOM 结构会有助于性能的提升。例如，可以通过 CSS 隐藏或显示节点，而不是真的移除或添加 DOM 节点。

### list diff (element diff)
> 对于节点的比较，其实只有三种操作，插入、移动和删除。（这里最麻烦的是移动，后面会介绍实现）。当被diff节点处于同一层级时，通过三种节点操作新旧节点进行更新：插入，移动和删除，同时提供给用户设置key属性的方式调整diff更新中默认的排序方式，在没有key值的列表diff中，只能通过按顺序进行每个元素的对比，更新，插入与删除，在数据量较大的情况下，diff效率低下，如果能够基于设置key标识尽心diff，就能够快速识别新旧列表之间的变化内容，提升diff效率。